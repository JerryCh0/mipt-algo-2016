\documentclass{article}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel} 
\usepackage{cmap} 
\usepackage{soulutf8}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\begin{document}
\subparagraph{\textit{ Задача ''Tricky mutex [tricky]'', Ткаченко Дмитрий, команда PQ.}}

\subparagraph{Решение:} Предположим, что два потока А и В одновременно попали в критическую секцию (не нарушая общности, вторым в нее попал B). Тогда при проверке условия $(thread\_count.fetch\_add(1) > 0$ он получил значение $thread\_count$ равное нулю (если бы оно было отрицательным, то дальше могли бы заходить еще потоки, если бы было положительным - не зашел бы В). Так как поток А зашел раньше потока В, то он тоже наблюдал значение переменной $thread\_count$ равное нулю. Тем самым между двумя этими проверками было совершено либо нулевое число увеличений счетчика и его уменьшений, либо равное. (с момента последнего $unlock$). Тогда если не совершалось увеличений, то никто и не заходил в критическую секцию, но это не так. Значит было совершенно одинаковое число увеличений и уменьшений в wait-секции. Любой поток, находящийся в ожидании, делает уменьшений не больше, чем увеличений, но поток А (так как он зашел в критическую секцию), сделал на одно увеличение больше, тем самым нарушается возможность наблюдения $thread\_count$ равного нулю потоком В (разобраны все варианты).
\newline
	Поймем теперь, почему данный мьютекс не гарантирует свободу от взаимной блокировки. 

\subparagraph{Ответ:} Гарантирует взаимное исключение, но не свободу от взаимной блокировки.

\end{document}

